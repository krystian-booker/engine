// evsm_prefilter.comp - EVSM Moment Generation Compute Shader
// Generates EVSM moments from standard depth shadow maps

// Input: standard depth shadow map
[[vk::binding(0, 0)]]
Texture2D<float> inputDepthMap : register(t0);

[[vk::binding(0, 0)]]
SamplerState depthSampler : register(s0);

// Output: EVSM moments (RGBA32F)
// RG = positive moments (mean, mean^2)
// BA = negative moments (mean, mean^2)
[[vk::binding(1, 0)]]
RWTexture2D<float4> outputMoments : register(u0);

// Push constants for parameters
struct PushConstants {
    float positiveExponent;
    float negativeExponent;
    uint mipLevel;
    uint padding;
};

[[vk::push_constant]]
ConstantBuffer<PushConstants> pushConstants;

// Compute EVSM moments from depth
float4 ComputeMoments(float depth, float positiveExp, float negativeExp) {
    float pos = exp(positiveExp * depth);
    float neg = -exp(-negativeExp * depth);

    return float4(
        pos, pos * pos,   // Positive moments (mean, mean^2)
        neg, neg * neg    // Negative moments (mean, mean^2)
    );
}

[numthreads(8, 8, 1)]
void main(uint3 dispatchThreadID : SV_DispatchThreadID) {
    uint2 coord = dispatchThreadID.xy;

    // Get output texture dimensions
    uint width, height;
    outputMoments.GetDimensions(width, height);

    if (coord.x >= width || coord.y >= height) {
        return;
    }

    // Sample depth from input shadow map
    float2 uv = (float2(coord) + 0.5) / float2(width, height);
    float depth = inputDepthMap.SampleLevel(depthSampler, uv, pushConstants.mipLevel).r;

    // Compute moments
    float4 moments = ComputeMoments(depth, pushConstants.positiveExponent, pushConstants.negativeExponent);

    // Write to output
    outputMoments[coord] = moments;
}

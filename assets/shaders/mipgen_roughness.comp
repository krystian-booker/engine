#include "mipgen_common.hlsl"

[[vk::binding(0, 0)]] Texture2D<float4> g_Roughness;
[[vk::binding(1, 0)]] RWTexture2D<float4> g_Destination;
[[vk::binding(2, 0)]] Texture2D<float4> g_Normals;

struct MipgenPushConstants
{
    uint SrcWidth;
    uint SrcHeight;
    uint DstWidth;
    uint DstHeight;
    uint SrcLevel;
    uint Options;
};

[[vk::push_constant]]
MipgenPushConstants g_Params;

#define MIPGEN_FLAG_HAS_NORMALS 0x1u

[numthreads(8, 8, 1)]
void main(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    uint2 dstCoord = dispatchThreadID.xy;
    if (dstCoord.x >= g_Params.DstWidth || dstCoord.y >= g_Params.DstHeight)
    {
        return;
    }

    uint2 srcBase = dstCoord * 2;
    uint2 srcSize = uint2(g_Params.SrcWidth, g_Params.SrcHeight);
    uint2 maxCoord = max(srcSize - 1, uint2(0, 0));

    uint2 fetchCoords[4];
    fetchCoords[0] = ClampCoord(srcBase, maxCoord);
    fetchCoords[1] = ClampCoord(srcBase + uint2(1, 0), maxCoord);
    fetchCoords[2] = ClampCoord(srcBase + uint2(0, 1), maxCoord);
    fetchCoords[3] = ClampCoord(srcBase + uint2(1, 1), maxCoord);

    float roughSum = 0.0f;
    float metalnessMin = 1.0f;    // G channel: use min for metalness
    float aoProduct = 1.0f;        // B channel: use multiply for AO (geometric mean)
    float alphaSum = 0.0f;         // A channel: average (unused in most PBR)
    float3 normalSum = float3(0.0f, 0.0f, 0.0f);

    const bool hasNormals = (g_Params.Options & MIPGEN_FLAG_HAS_NORMALS) != 0u;

    [unroll]
    for (uint i = 0; i < 4; ++i)
    {
        const int3 sampleCoord = int3(fetchCoords[i], g_Params.SrcLevel);
        float4 roughSample = g_Roughness.Load(sampleCoord);

        roughSum += roughSample.r;             // R: Roughness (will apply Toksvig)
        metalnessMin = min(metalnessMin, roughSample.g);  // G: Metalness (min preserves non-metal)
        aoProduct *= roughSample.b;            // B: AO (multiply preserves occlusion)
        alphaSum += roughSample.a;             // A: Unused/height (average)

        if (hasNormals)
        {
            float4 normalSample = g_Normals.Load(sampleCoord);
            normalSum += DecodeNormal(normalSample.xyz);
        }
    }

    float averagedRoughness = roughSum * 0.25f;
    float filteredMetalness = metalnessMin;
    float filteredAO = aoProduct;  // Already geometric mean via multiplication
    float averagedAlpha = alphaSum * 0.25f;

    float filteredRoughness = saturate(averagedRoughness);

    if (hasNormals)
    {
        float3 avgNormal = normalSum * 0.25f;
        float lengthN = saturate(length(avgNormal));

        if (lengthN > 1e-5f)
        {
            float alpha = filteredRoughness * filteredRoughness;
            float variance = (1.0f - lengthN) / lengthN;
            float adjustedAlpha = saturate(alpha + variance);
            filteredRoughness = sqrt(adjustedAlpha);
        }
        else
        {
            filteredRoughness = 1.0f;
        }
    }

    g_Destination[dstCoord] = float4(
        saturate(filteredRoughness),  // R: Toksvig-filtered roughness
        saturate(filteredMetalness),  // G: Min metalness (preserves non-metal)
        saturate(filteredAO),         // B: Geometric mean AO (preserves occlusion)
        saturate(averagedAlpha)       // A: Averaged (unused/height)
    );
}

// Compute shader to generate irradiance map from environment cubemap
// Convolves the environment map for diffuse IBL
#version 450

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0, rgba16f) uniform writeonly imageCube outputIrradiance;
layout (binding = 1) uniform samplerCube inputEnvironment;

layout (push_constant) uniform PushConstants {
    uint faceIndex;
    float deltaPhi;
    float deltaTheta;
} pc;

const float PI = 3.14159265359;

// Convert cubemap coordinates to direction vector
vec3 GetDirectionFromCubeFace(uint face, vec2 uv) {
    vec2 ndc = uv * 2.0 - 1.0;

    vec3 dir;
    if (face == 0) {
        dir = vec3(1.0, -ndc.y, -ndc.x);
    } else if (face == 1) {
        dir = vec3(-1.0, -ndc.y, ndc.x);
    } else if (face == 2) {
        dir = vec3(ndc.x, 1.0, ndc.y);
    } else if (face == 3) {
        dir = vec3(ndc.x, -1.0, -ndc.y);
    } else if (face == 4) {
        dir = vec3(ndc.x, -ndc.y, 1.0);
    } else {
        dir = vec3(-ndc.x, -ndc.y, -1.0);
    }

    return normalize(dir);
}

void main() {
    ivec2 outputSize = imageSize(outputIrradiance);
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    if (pixelCoord.x >= outputSize.x || pixelCoord.y >= outputSize.y) {
        return;
    }

    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(outputSize);
    vec3 N = GetDirectionFromCubeFace(pc.faceIndex, uv);

    // Construct orthonormal basis around N
    vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);

    // Convolution - integrate hemisphere
    vec3 irradiance = vec3(0.0);
    float sampleCount = 0.0;

    for (float phi = 0.0; phi < 2.0 * PI; phi += pc.deltaPhi) {
        for (float theta = 0.0; theta < 0.5 * PI; theta += pc.deltaTheta) {
            // Spherical to Cartesian (in tangent space)
            vec3 tangentSample = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));

            // Transform to world space
            vec3 sampleVec = tangent * tangentSample.x + bitangent * tangentSample.y + N * tangentSample.z;

            // Sample environment map
            vec3 radiance = texture(inputEnvironment, sampleVec).rgb;

            // Accumulate with cosine weight
            irradiance += radiance * cos(theta) * sin(theta);
            sampleCount += 1.0;
        }
    }

    irradiance = PI * irradiance / sampleCount;

    imageStore(outputIrradiance, ivec3(pixelCoord, pc.faceIndex), vec4(irradiance, 1.0));
}

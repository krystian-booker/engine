// Auto-exposure calculation
// Computes average scene luminance for automatic exposure adjustment
#version 450

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0) uniform sampler2D hdrInput;
layout (binding = 1, r32f) uniform writeonly image2D luminanceOutput;

// Shared memory for parallel reduction
shared float sharedLuminance[16 * 16];

float Luminance(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = textureSize(hdrInput, 0);

    uint localIndex = gl_LocalInvocationID.y * 16 + gl_LocalInvocationID.x;

    // Sample and calculate luminance
    float luma = 0.0;
    if (pixelCoord.x < imageSize.x && pixelCoord.y < imageSize.y) {
        vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(imageSize);
        vec3 color = texture(hdrInput, uv).rgb;
        luma = log(max(Luminance(color), 0.0001));  // Log luminance for better perception
    }

    sharedLuminance[localIndex] = luma;
    barrier();

    // Parallel reduction to compute average
    for (uint stride = 128; stride > 0; stride >>= 1) {
        if (localIndex < stride) {
            sharedLuminance[localIndex] += sharedLuminance[localIndex + stride];
        }
        barrier();
    }

    // Write average luminance
    if (localIndex == 0) {
        float avgLogLuminance = sharedLuminance[0] / 256.0;  // 16x16 = 256
        float avgLuminance = exp(avgLogLuminance);

        // Calculate exposure (simple key value)
        float keyValue = 0.18;  // Middle gray
        float exposure = keyValue / (avgLuminance + 0.0001);

        imageStore(luminanceOutput, ivec2(gl_WorkGroupID.xy), vec4(exposure, 0.0, 0.0, 0.0));
    }
}

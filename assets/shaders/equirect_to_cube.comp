// Compute shader to convert equirectangular HDR image to cubemap
#version 450

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0, rgba16f) uniform writeonly imageCube outputCube;
layout (binding = 1) uniform sampler2D inputEquirect;

layout (push_constant) uniform PushConstants {
    uint faceIndex;
    uint mipLevel;
} pc;

const float PI = 3.14159265359;

// Convert cubemap coordinates to direction vector
vec3 GetDirectionFromCubeFace(uint face, vec2 uv) {
    // UV in [0,1], convert to [-1,1]
    vec2 ndc = uv * 2.0 - 1.0;

    vec3 dir;
    if (face == 0) {      // +X
        dir = vec3(1.0, -ndc.y, -ndc.x);
    } else if (face == 1) { // -X
        dir = vec3(-1.0, -ndc.y, ndc.x);
    } else if (face == 2) { // +Y
        dir = vec3(ndc.x, 1.0, ndc.y);
    } else if (face == 3) { // -Y
        dir = vec3(ndc.x, -1.0, -ndc.y);
    } else if (face == 4) { // +Z
        dir = vec3(ndc.x, -ndc.y, 1.0);
    } else {              // -Z
        dir = vec3(-ndc.x, -ndc.y, -1.0);
    }

    return normalize(dir);
}

// Convert direction to equirectangular UV coordinates
vec2 DirectionToEquirectUV(vec3 dir) {
    float phi = atan(dir.z, dir.x);
    float theta = asin(dir.y);

    vec2 uv;
    uv.x = phi / (2.0 * PI) + 0.5;
    uv.y = theta / PI + 0.5;

    return uv;
}

void main() {
    ivec2 outputSize = imageSize(outputCube);
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    if (pixelCoord.x >= outputSize.x || pixelCoord.y >= outputSize.y) {
        return;
    }

    // Calculate UV coordinates [0,1]
    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(outputSize);

    // Get direction for this pixel
    vec3 direction = GetDirectionFromCubeFace(pc.faceIndex, uv);

    // Sample equirectangular map
    vec2 equirectUV = DirectionToEquirectUV(direction);
    vec4 color = texture(inputEquirect, equirectUV);

    // Write to cubemap face
    imageStore(outputCube, ivec3(pixelCoord, pc.faceIndex), color);
}
